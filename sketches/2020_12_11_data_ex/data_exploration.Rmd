---
title: "CTDS Scalability pulse check: NAVFAC Harbor Seals Exploration"
author: "Josh"
date: "3/16/2021"
output: 
  pdf_document:
    number_sections: true
---

# Overview

This is a living document with some basic explorations of SATTAG data to better understand the computational complexity of the analysis.  Specifically, ultimate goals are to try to investigate:

1. Size of discrete spatial domain.
3. Prior information about an animal's maximum speed, and how this influences the lengths of longest paths between observations.
2. Lengths of longest and shortest paths between observations, which is a function of animal speed and time between observations.
4. (Throughout) Points that should be excluded from analysis.  For example, this includes observations with redundant timestamps and observations with nearly-redundant timestamps but large disagreement in location, potentially due to ARGOS measurement error.  If large disagreements are within measurement error, then the analysis could include the points as long as measurement error is incdlued in analysis.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = TRUE, message = FALSE, fig.align = 'center')
```

```{r libraries, warning=FALSE}
library(readr)
library(dplyr)
library(fields)
library(ggplot2)
library(ggthemes)
library(ggspatial)
library(ggpubr)
library(ncdf4)
library(raster)
library(sp)
library(mapproj)
library(ggnewscale)
library(viridis)
library(scales)
```

```{r load_gps}
# subject to explore
animal_id = 166450

# load all gps data
daflocsAll <- readr::read_csv(
  file.path('data', 'NAVFAC-Harbor-Seals', '2018-06-20-navfacOutput.txt')
)

# remove poor GPS fixes
daflocs <- dplyr::filter(daflocsAll, outlier_al == 0)

# extract data for individual animal
animalobs = daflocs %>% filter(tag_ident == animal_id)
```

```{r load_bathymetry}
# set spatial extents to extract
extent_vec = c(min_lon = -77, max_lon = -69, min_lat = 35, max_lat = 42)
# extent_vec = c(min_lon = -75, max_lon = -70, min_lat = 38, max_lat = 41)

domain.extent = extent(extent_vec)

# load, crop, and merge bathymetry files
bathy = do.call(merge, lapply(
  dir(path = file.path('data', 'STRM_30_PLUS'), pattern = '.nc',
      full.names = TRUE),
  function(f) crop(raster(f), domain.extent)
))

# set CRS
crs(bathy) = '+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0'
```

```{r ellipse_fn}
ellipsePoints = function(center, major, minor, angle, segments) {
  angles = (0:segments) * 2 * pi/segments
  unit.circle = cbind(cos(angles), sin(angles))
  cos.angle = cos(angle)
  sin.angle = sin(angle)
  Q = matrix(c(
    minor * cos.angle, minor * -sin.angle,
    major * sin.angle, major * cos.angle
  ), ncol = 2, byrow = TRUE)
  t(center + t(unit.circle %*% Q))
}
```

```{r preassemble_plot}
# plotting projection
plot_crs = '+proj=aea +lat_1=27.333 +lat_2=40.666 +lon_0=-78'

animalobs.unprojected = SpatialPoints(
  coords = animalobs[, c('long', 'lat')], 
  proj4string = crs(bathy)
)

obserrors.projected = do.call(rbind,apply(
  animalobs[, c('FID', 'long', 'lat', 'semi_major', 'semi_minor', 'orientatio')], 1,
  function(r) {
    # project lon/lat GPS reading to a local coordinate system
    # so that the coordinates are compatible with the error scale (m)
    ctr = SpatialPoints(coords = matrix(r[c('long', 'lat')], nrow = 1), 
                        proj4string = crs(bathy))
    ctr.projected = spTransform(ctr, CRS(plot_crs))
    # points for error ellipse
    res = data.frame(
      ellipsePoints(center = as.numeric(coordinates(ctr.projected)), 
                  major = as.numeric(r['semi_major']), 
                  minor = as.numeric(r['semi_minor']), segments = 50,
                  angle = (90 - as.numeric(r['orientatio'])) / 180 * pi)
    )
    res$id = r['FID']
    res
}))

# projected GPS coordinates, for plotting
animalobs.projected = spTransform(animalobs.unprojected, CRS(plot_crs))

# subsample data, for faster plotting
bathy.downsampled = sampleRegular(x = bathy, size = 1e6, asRaster = TRUE)

# projected bathymetry coordinates, for plotting
bathy.projected = projectRaster(from = bathy.downsampled, crs = plot_crs)

# separate land from bathymetry
land.mask = bathy.projected
land.mask[land.mask <= 0] = NA
land.mask[land.mask > 0] = 1
bathy.projected[bathy.projected > 0] = NA
bathy.projected = bathy.projected * -1

# munge raster to tidy format
df = data.frame(coordinates(bathy.projected), depth = values(bathy.projected))
df.land = data.frame(coordinates(land.mask), mask = values(land.mask))

```

# Spatial domain

```{r build_plot, dependson='preassemble_plot', fig.cap='GPS tracks with ARGOS error ellipses for target animal, plotted against bathymetry and coastline.'}
# plot gps track against bathymetry and coastline
ggplot(mapping = aes(x = x, y = y)) + 
  # bathymetry
  geom_raster(mapping = aes(fill = depth), data = df) + 
  scale_fill_distiller('Depth (m)', palette = 'Blues', direction = -1,
                       na.value = 'transparent', trans = 'reverse') +
  # land mask
  new_scale_fill() + 
  guides(fill = 'none') + 
  geom_raster(mapping = aes(fill = mask), data = df.land) + 
  scale_fill_viridis_c(na.value = 'transparent') +
  # observation error ellipses
  geom_polygon(mapping = aes(x = X1, y = X2, group = id), 
               data = obserrors.projected, inherit.aes = FALSE, 
               fill = NA, col = rgb(0,0,0,.2), size = .125) + 
  # observations
  geom_path(mapping = aes(x = long, y = lat), inherit.aes = FALSE,
            data = data.frame(animalobs.projected)) +
  geom_point(mapping = aes(x = long, y = lat), inherit.aes = FALSE,
             data = data.frame(animalobs.projected), size = .5) +
  # map extent labels
  scale_x_continuous(
    breaks = range(coordinates(bathy.projected)[,1]),
    labels = telefit:::lon_trans()$format(
      extent_vec[c('min_lon', 'max_lon')]
  )) +
  scale_y_continuous(
    breaks = range(coordinates(bathy.projected)[,2]),
    labels = telefit:::lat_trans()$format(
      extent_vec[c('min_lat', 'max_lat')]
  )) +
  # formatting
  coord_equal() + 
  theme_few() + 
  theme(panel.border = element_blank(), 
        axis.title = element_blank(), 
        axis.ticks = element_blank())

```

```{r, eval = FALSE}
# compute distances between observations (in km)
obs_dists = sapply(2:nrow(animalobs), function(obs_ind) {
  rdist.earth(x1 = as.matrix(animalobs[obs_ind - 1, c('long','lat')]),
              x2 = as.matrix(animalobs[obs_ind, c('long','lat')]), 
              miles = FALSE)
})
```

```{r observed_distances}
# distances between gps fixes (km)
obs_changes = data.frame(
  dist = sapply(2:nrow(animalobs), function(obs_ind) {
    rdist.earth(x1 = as.matrix(animalobs[obs_ind - 1, c('long','lat')]),
                x2 = as.matrix(animalobs[obs_ind, c('long','lat')]), 
                miles = FALSE)
    })
)

# times between gps fixes (h)
obs_changes$time = diff(animalobs$timestamp)
units(obs_changes$time) = 'hours'
```

# Observed speeds

```{r plot_obs_speeds, fig.cap='We see that distances decrease with speed, which is important because there are a few pairs of observations with identical timestamps.  This EDA plot suggests we can treat the redundant timestamps as equivalent observations, and use timestamps to deduplicate data.', fig.height=4, fig.width=8,}
pl1 = ggplot(obs_changes, aes(x = time, y = dist)) + 
  geom_point() + 
  xlab('Time between observations (h)') + 
  # ylab('Distance between observations (km)') + 
  ylab('') + 
  theme_few() + 
  theme(panel.border = element_blank()) + 
  ggtitle('All times')

pl2 = ggplot(obs_changes %>% filter(time<.5), aes(x = time, y = dist)) + 
  geom_point() + 
  xlab('Time between observations (h)') + 
  ylab('Distance between observations (km)') +
  theme_few() + 
  theme(panel.border = element_blank()) + 
  ggtitle('Short times')

ggarrange(pl2, pl1, ncol = 2)
```

```{r observed_speeds}
# compute the average speed between observations, 
# but only for non-duplicate timestamps
finite_speeds = obs_changes %>% 
  filter(time > 0) %>% 
  mutate(speed_km_h = dist/as.numeric(time),
         speed_m_s = speed_km_h * 1e3 /3600)
```

```{r observed_speed_plot, fig.cap='A) Empirical, average speed the animal was moving between GPS fixes (after removing duplicate timestamps, which would otherwise suggest infinite speed).  B) The fastest speeds are associated with measurements taken at very short time intervals.  In conjunction with Figure \\ref{fig:plot_obs_speeds}, the issue might be due to ARGOS measurement error because there are many temporally-adjacent observations that have apparently large distances between them.', fig.height=4, fig.width=8}
pl1 = ggplot(finite_speeds, aes(x = speed_m_s)) + 
  stat_density(geom = 'line') + 
  scale_x_log10('Observed speed (m/s)', labels = comma) +
  ylab('Density') + 
  theme_few() + 
  theme(panel.border = element_blank())

# finite_speeds$ecdf = ecdf(finite_speeds$speed)(finite_speeds$speed)
# pl2 = ggplot(finite_speeds %>% 
#                dplyr::select(speed, ecdf) %>% 
#                unique(), 
#              aes(x = speed, y = ecdf)) + 
#   geom_line() + 
#   scale_x_log10('Observed speed (km/h)', labels = comma) + 
#   ylab('Empirical CDF') + 
#   geom_point() + 
#   # theme_few() + 
#   theme(panel.border = element_blank())

pl2 = ggplot(finite_speeds, aes(x = as.numeric(time)*3600, y = speed_km_h)) + 
  geom_point() + 
  theme_few() + 
  scale_x_log10('Time between observations (sec)', labels = comma) +
  scale_y_log10('Observed speed (km/h)', labels = comma) + 
  theme(panel.border = element_blank())
  
ggarrange(pl1, pl2, nrow = 1, labels = 'AUTO')
```


# Measurement error

```{r build_plot_zoom, dependson='preassemble_plot', fig.cap='GPS tracks near Norfolk, VA with ARGOS error ellipses for target animal, plotted against bathymetry and coastline.', warning=FALSE}

xlimcuts = c(0.12, .31)
ylimcuts = c(.22, .41)

convex_combination = function(points, alpha) {
  sapply(alpha, function(a) {
    points[1] * (1-a) + points[2] * a
  })
}

xlims = convex_combination(range(coordinates(bathy.projected)[,1]), xlimcuts)
ylims = convex_combination(range(coordinates(bathy.projected)[,2]), ylimcuts)

cut_extents = SpatialPoints(expand.grid(x = xlims, y = ylims), CRS(plot_crs))
cut_extents = spTransform(cut_extents, crs(bathy))

# plot gps track against bathymetry and coastline
ggplot(mapping = aes(x = x, y = y)) + 
  # bathymetry
  geom_raster(mapping = aes(fill = depth), data = df) + 
  scale_fill_distiller('Depth (m)', palette = 'Blues', direction = -1,
                       na.value = 'transparent', trans = 'reverse') +
  # land mask
  new_scale_fill() + 
  guides(fill = 'none') + 
  geom_raster(mapping = aes(fill = mask), data = df.land) + 
  scale_fill_viridis_c(na.value = 'transparent') +
  # observation error ellipses
  geom_polygon(mapping = aes(x = X1, y = X2, group = id), 
               data = obserrors.projected, inherit.aes = FALSE, 
               fill = NA, col = rgb(0,0,0,.2), size = .125) + 
  # observations
  geom_path(mapping = aes(x = long, y = lat), inherit.aes = FALSE,
            data = data.frame(animalobs.projected)) +
  geom_point(mapping = aes(x = long, y = lat), inherit.aes = FALSE,
             data = data.frame(animalobs.projected), size = .5) +
  # map extent labels
  scale_x_continuous(
    breaks = xlims,
    labels = telefit:::lon_trans()$format(
      range(round(cut_extents@coords[,1]))
    ), 
    limits = xlims
  ) +
  scale_y_continuous(
    breaks = ylims,
    labels = telefit:::lat_trans()$format(
      range(round(cut_extents@coords[,2]))
    ),
    limits = ylims
  ) +
  # formatting
  coord_equal() + 
  theme_few() + 
  theme(panel.border = element_blank(), 
        axis.title = element_blank(), 
        axis.ticks = element_blank())
```

```{r measurement_error_parameterization}
# Parameterizing covariance matrices following McClintock et al. (2015)
error_params = apply(animalobs[, c('semi_major', 'semi_minor', 'orientatio')], 
                     1, function(r) {
  Mtsq = r['semi_major']^2
  mtsq = r['semi_minor']^2
  ct = (90 - r['orientatio']) / 180 * pi
  ct.sin = sin(ct)
  ct.cos = cos(ct)
  sigma_xy = (Mtsq - mtsq) / 2 * ct.cos * ct.sin
  matrix(c(
    Mtsq / 2 * ct.sin^2 + mtsq / 2 * ct.cos^2, sigma_xy, 
    sigma_xy, Mtsq / 2 * ct.cos^2 + mtsq / 2 * ct.sin^2
  ), nrow = 2, byrow = TRUE)
})
```


# Depth diffusions

```{r depth_diffusion, results='hide'}

# devtools::install('packages/dsmovetools/')
library(dsmovetools)

template_bins = read.csv('sketches/2020_12_11_data_ex/bin2352.csv')

# order of coords iterates over latitude first, then longitude
coords = coordinates(bathy)
lons = unique(coords[,1])
lats = unique(coords[,2])

obs_ind = 1

a0coords = matrix(
  c(which.min(abs(animalobs$lat[obs_ind] - lats)),
    which.min(abs(animalobs$long[obs_ind] - lons)),
    1) - 1,
  nrow = 1
)

# so, we see that raster data is stored in row-major order since the first 
# entries of the data vector correspond to the first row of bathy
heights = as.numeric(getValues(bathy))
identical(bathy[1,], heights[1:ncol(bathy)])
identical(bathy[2,], heights[ncol(bathy) + 1:ncol(bathy)])

# but we can get the data in col-major order if we transpose a raster first 
# since the first entries of the transposed data vector corerspond to the first 
# column of bathy
heights_t = as.numeric(getValues(t(bathy)))
identical(bathy[,1], heights_t[1:nrow(bathy)])
identical(bathy[,2], heights_t[nrow(bathy) + 1:nrow(bathy)])

# we see that the way to access elevations is via bathy[lat_ind, lon_ind]
franklin_va = c(lon = -76.928739, lat = 36.678858, elevation = 12)
franklin_inds = c(lon = which.min(abs(franklin_va['lon'] - lons)),
                  lat = which.min(abs(franklin_va['lat'] - lats)))
bathy[franklin_inds['lat'], franklin_inds['lon']]
chesapeake_va = c(lon = -76.269044, lat = 36.770355, elevation = 9)
chesapeake_inds = c(lon = which.min(abs(chesapeake_va['lon'] - lons)),
                  lat = which.min(abs(chesapeake_va['lat'] - lats)))
bathy[chesapeake_inds['lat'], chesapeake_inds['lon']]

template_bin_tops = - template_bins$center + template_bins$halfwidth

# diffuse mass
af = data.frame(
  dsmovetools:::FFRWLightLogConstrained(
    a0coords = a0coords, 
    log_a0values = 0, 
    dims = c(nrow(bathy), ncol(bathy), 16), 
    steps = 100, 
    surface_heights = getValues(t(bathy)), 
    domain_heights = template_bin_tops
  )
)
colnames(af) = c('lat_ind', 'lon_ind', 'z_ind', 'log_mass')

# longer diffusion
af_longer = data.frame(
  dsmovetools:::FFRWLightLogConstrained(
    a0coords = a0coords, 
    log_a0values = 0, 
    dims = c(nrow(bathy), ncol(bathy), 16), 
    steps = 200, 
    surface_heights = getValues(t(bathy)), 
    domain_heights = template_bin_tops
  )
)
colnames(af_longer) = c('lat_ind', 'lon_ind', 'z_ind', 'log_mass')

# # almost all of the mass is stuck in the shallowest bin
# table(af$z_ind)

# enrich diffusion, for plotting, where we undo the 0-based C++ indexing
af$lat = lats[af$lat_ind + 1]
af$lon = lons[af$lon_ind + 1]

# projected GPS coordinates, for plotting
af.unprojected = SpatialPoints(
  coords = af[, c('lon', 'lat')], 
  proj4string = crs(bathy)
)
af.projected = spTransform(af.unprojected, CRS(plot_crs))

# enrich diffusion, for plotting, where we undo the 0-based C++ indexing
af_longer$lat = lats[af_longer$lat_ind + 1]
af_longer$lon = lons[af_longer$lon_ind + 1]

# projected GPS coordinates, for plotting
af_longer.unprojected = SpatialPoints(
  coords = af_longer[, c('lon', 'lat')], 
  proj4string = crs(bathy)
)
af_longer.projected = spTransform(af_longer.unprojected, CRS(plot_crs))
```

```{r show_diffusion, dependson='depth_diffusion', fig.cap='Discrete-space diffusion respects depth and land boundaries.  Circle of points equidistant from observation help illustrate how the constraints imply mass is not equally distributed around equidistant-points.  Depth contours indicate that most of the diffusion is in the surface bin.', warning=FALSE}
library(metR)
library(ggforce)
library(fields)

xlimcuts = c(0.12, .31)
ylimcuts = c(.22, .41)

convex_combination = function(points, alpha) {
  sapply(alpha, function(a) {
    points[1] * (1-a) + points[2] * a
  })
}

xlims = convex_combination(range(coordinates(bathy.projected)[,1]), xlimcuts)
ylims = convex_combination(range(coordinates(bathy.projected)[,2]), ylimcuts)

cut_extents = SpatialPoints(expand.grid(x = xlims, y = ylims), CRS(plot_crs))
cut_extents = spTransform(cut_extents, crs(bathy))

grid_spacing = rdist.earth(coords[1:2,], miles = FALSE)[2] * 1e3

# visualize diffusion against bathymetry and coastline
ggplot(mapping = aes(x = x, y = y), data = df) +
  # diffused mass
  new_scale_fill() +
  geom_tile(mapping = aes(x = lon, y = lat, fill = log_mass,
                          width = grid_spacing, height = grid_spacing, 
                          alpha = .5),
            data = cbind(data.frame(af.projected),
                         log_mass = af$log_mass),
            inherit.aes = FALSE) +
  scale_fill_viridis_c(na.value = 'transparent', direction = -1) +
  guides(alpha = 'none') + 
    # land mask
  new_scale_fill() +
  guides(fill = 'none') +
  geom_raster(mapping = aes(fill = mask), data = df.land, alpha = .5) +
  scale_fill_viridis_c(na.value = 'transparent') +
  # bathymetry contours
  geom_contour2(mapping = aes(z = depth), data = df, 
                breaks = -template_bin_tops, alpha = .5) + 
  geom_text_contour(mapping = aes(z = depth), data = df, 
                    breaks = -template_bin_tops) + 
  # observations
  geom_point(mapping = aes(x = long, y = lat), inherit.aes = FALSE,
             data = data.frame(animalobs.projected)[obs_ind,], size = .5) +
  # semi-circle of locations that are equidistant from observation (50km radius)
  geom_arc(mapping = aes(x0 = long, y0 = lat, r = 1e5/2, 
                         start = 0 - 40 * pi / 180, 
                         end = pi + 40 * pi / 180), 
              inherit.aes = FALSE, alpha = .5, 
              data = data.frame(animalobs.projected)[obs_ind,]) + 
  # map extent labels
  scale_x_continuous(
    breaks = xlims,
    labels = telefit:::lon_trans()$format(
      range(round(cut_extents@coords[,1]))
    ),
    limits = xlims
  ) +
  scale_y_continuous(
    breaks = ylims,
    labels = telefit:::lat_trans()$format(
      range(round(cut_extents@coords[,2]))
    ),
    limits = ylims
  ) +
  # formatting
  coord_equal() + 
  theme_few() + 
  theme(panel.border = element_blank(), 
        axis.title = element_blank(), 
        axis.ticks = element_blank())
```

```{r show_longer_diffusion, dependson='depth_diffusion', warning=FALSE, fig.width = 8, fig.height=4, fig.cap='Illustration of diffused mass at different depth levels, which shows that the depth data are, indeed, constraining the diffusion.'}
library(metR)
library(ggforce)
library(fields)
library(ggpubr)

xlimcuts = c(0.12, .31)
ylimcuts = c(.22, .41)

convex_combination = function(points, alpha) {
  sapply(alpha, function(a) {
    points[1] * (1-a) + points[2] * a
  })
}

xlims = convex_combination(range(coordinates(bathy.projected)[,1]), xlimcuts)
ylims = convex_combination(range(coordinates(bathy.projected)[,2]), ylimcuts)

cut_extents = SpatialPoints(expand.grid(x = xlims, y = ylims), CRS(plot_crs))
cut_extents = spTransform(cut_extents, crs(bathy))

grid_spacing = rdist.earth(coords[1:2,], miles = FALSE)[2] * 1e3

# visualize diffusion against bathymetry and coastline
pl_surface = ggplot(mapping = aes(x = x, y = y), data = df) +
  # diffused mass
  new_scale_fill() +
  geom_tile(mapping = aes(x = lon, y = lat, fill = log_mass,
                          width = grid_spacing, height = grid_spacing, 
                          alpha = .5),
            data = cbind(data.frame(af_longer.projected),
                         log_mass = af_longer$log_mass,
                         z_ind = af_longer$z_ind) %>% 
              filter(z_ind == 0),
            inherit.aes = FALSE) +
  scale_fill_viridis_c(na.value = 'transparent', direction = -1) +
  guides(alpha = 'none') + 
    # land mask
  new_scale_fill() +
  guides(fill = 'none') +
  geom_raster(mapping = aes(fill = mask), data = df.land, alpha = .5) +
  scale_fill_viridis_c(na.value = 'transparent') +
  # bathymetry contours
  geom_contour2(mapping = aes(z = depth), data = df, 
                breaks = -template_bin_tops, alpha = .5) + 
  # observations
  geom_point(mapping = aes(x = long, y = lat), inherit.aes = FALSE,
             data = data.frame(animalobs.projected)[obs_ind,], size = .5) +
  # semi-circle of locations that are equidistant from observation (50km radius)
  geom_arc(mapping = aes(x0 = long, y0 = lat, r = 1e5/2, 
                         start = 0 - 40 * pi / 180, 
                         end = pi + 40 * pi / 180), 
              inherit.aes = FALSE, alpha = .5, 
              data = data.frame(animalobs.projected)[obs_ind,]) + 
  # map extent labels
  scale_x_continuous(
    breaks = xlims,
    labels = telefit:::lon_trans()$format(
      range(round(cut_extents@coords[,1]))
    ),
    limits = xlims
  ) +
  scale_y_continuous(
    breaks = ylims,
    labels = telefit:::lat_trans()$format(
      range(round(cut_extents@coords[,2]))
    ),
    limits = ylims
  ) +
  # formatting
  coord_equal() + 
  theme_few() + 
  theme(panel.border = element_blank(), 
        axis.title = element_blank(), 
        axis.ticks = element_blank())

pl_bin1 = ggplot(mapping = aes(x = x, y = y), data = df) +
  # diffused mass
  new_scale_fill() +
  geom_tile(mapping = aes(x = lon, y = lat, fill = log_mass,
                          width = grid_spacing, height = grid_spacing, 
                          alpha = .5),
            data = cbind(data.frame(af_longer.projected),
                         log_mass = af_longer$log_mass,
                         z_ind = af_longer$z_ind) %>% 
              filter(z_ind == 1),
            inherit.aes = FALSE) +
  scale_fill_viridis_c(na.value = 'transparent', direction = -1) +
  guides(alpha = 'none') + 
    # land mask
  new_scale_fill() +
  guides(fill = 'none') +
  geom_raster(mapping = aes(fill = mask), data = df.land, alpha = .5) +
  scale_fill_viridis_c(na.value = 'transparent') +
  # bathymetry contours
  geom_contour2(mapping = aes(z = depth), data = df, 
                breaks = -template_bin_tops, alpha = .5) + 
  # observations
  geom_point(mapping = aes(x = long, y = lat), inherit.aes = FALSE,
             data = data.frame(animalobs.projected)[obs_ind,], size = .5) +
  # semi-circle of locations that are equidistant from observation (50km radius)
  geom_arc(mapping = aes(x0 = long, y0 = lat, r = 1e5/2, 
                         start = 0 - 40 * pi / 180, 
                         end = pi + 40 * pi / 180), 
              inherit.aes = FALSE, alpha = .5, 
              data = data.frame(animalobs.projected)[obs_ind,]) + 
  # map extent labels
  scale_x_continuous(
    breaks = xlims,
    labels = telefit:::lon_trans()$format(
      range(round(cut_extents@coords[,1]))
    ),
    limits = xlims
  ) +
  scale_y_continuous(
    breaks = ylims,
    labels = telefit:::lat_trans()$format(
      range(round(cut_extents@coords[,2]))
    ),
    limits = ylims
  ) +
  # formatting
  coord_equal() + 
  theme_few() + 
  theme(panel.border = element_blank(), 
        axis.title = element_blank(), 
        axis.ticks = element_blank())

pl_bin2 = ggplot(mapping = aes(x = x, y = y), data = df) +
  # diffused mass
  new_scale_fill() +
  geom_tile(mapping = aes(x = lon, y = lat, fill = log_mass,
                          width = grid_spacing, height = grid_spacing, 
                          alpha = .5),
            data = cbind(data.frame(af_longer.projected),
                         log_mass = af_longer$log_mass,
                         z_ind = af_longer$z_ind) %>% 
              filter(z_ind == 2),
            inherit.aes = FALSE) +
  scale_fill_viridis_c(na.value = 'transparent', direction = -1) +
  guides(alpha = 'none') + 
    # land mask
  new_scale_fill() +
  guides(fill = 'none') +
  geom_raster(mapping = aes(fill = mask), data = df.land, alpha = .5) +
  scale_fill_viridis_c(na.value = 'transparent') +
  # bathymetry contours
  geom_contour2(mapping = aes(z = depth), data = df, 
                breaks = -template_bin_tops, alpha = .5) + 
  # observations
  geom_point(mapping = aes(x = long, y = lat), inherit.aes = FALSE,
             data = data.frame(animalobs.projected)[obs_ind,], size = .5) +
  # semi-circle of locations that are equidistant from observation (50km radius)
  geom_arc(mapping = aes(x0 = long, y0 = lat, r = 1e5/2, 
                         start = 0 - 40 * pi / 180, 
                         end = pi + 40 * pi / 180), 
              inherit.aes = FALSE, alpha = .5, 
              data = data.frame(animalobs.projected)[obs_ind,]) + 
  # map extent labels
  scale_x_continuous(
    breaks = xlims,
    labels = telefit:::lon_trans()$format(
      range(round(cut_extents@coords[,1]))
    ),
    limits = xlims
  ) +
  scale_y_continuous(
    breaks = ylims,
    labels = telefit:::lat_trans()$format(
      range(round(cut_extents@coords[,2]))
    ),
    limits = ylims
  ) +
  # formatting
  coord_equal() + 
  theme_few() + 
  theme(panel.border = element_blank(), 
        axis.title = element_blank(), 
        axis.ticks = element_blank())

ggarrange(pl_surface + ggtitle('Diffused mass at surface'), 
          pl_bin1 + ggtitle('Diffused mass at depth 1'), 
          pl_bin2 + ggtitle('Diffused mass at depth 2'), 
          nrow = 1, common.legend = TRUE, legend = 'bottom')
```


# Sample imputations


```{r forward_filter_to_loc}
library(dsmovetools)

gridInd = function(coord, obj) {
  # Returns the index of the lons and lats that best match the coord.
  # 
  # Parameters:
  #  coord - location to map to grid
  #  obj - raster object to map to 
  
  # distance between target coordinates and raster object
  dists = distanceFromPoints(obj, coord)
  # index of closest grid cell
  grid_ind = which.min(dists)
  # unique lon/lat coordinates in grid
  coords = coordinates(obj)
  lons = unique(coords[,1])
  lats = unique(coords[,2])
  # indices of best matching lons/lats
  c(lon_ind = which(coords[grid_ind,1] == lons), 
    lat_ind = which(coords[grid_ind,2] == lats))
}

x0 = gridInd(coord = animalobs[obs_ind,c('long','lat')], obj = bathy)
xf = gridInd(coord = animalobs[obs_ind + 1,c('long','lat')], obj = bathy)

a0coords = matrix(c(x0[c('lat_ind', 'lon_ind')] - 1, 0), nrow = 1)
afcoords = matrix(c(xf[c('lat_ind', 'lon_ind')] - 1, 0), nrow = 1)

af_dst = dsmovetools:::FFRWLogConstrainedDst(
  a0coords = a0coords, 
  log_a0values = 0, 
  dims = c(nrow(bathy), ncol(bathy), 16), 
  steps = 10, 
  surface_heights = getValues(t(bathy)), 
  domain_heights = template_bin_tops, 
  dstcoords = afcoords, max_steps = 200
)

af_dst_final = data.frame(af_dst[[length(af_dst)]])
colnames(af_dst_final) = c('lat_ind', 'lon_ind', 'z_ind', 'log_mass')

# enrich diffusion, for plotting, where we undo the 0-based C++ indexing
af_dst_final$lat = lats[af_dst_final$lat_ind + 1]
af_dst_final$lon = lons[af_dst_final$lon_ind + 1]

# projected GPS coordinates, for plotting
af_dst_final.unprojected = SpatialPoints(
  coords = af_dst_final[, c('lon', 'lat')], 
  proj4string = crs(bathy)
)
af_dst_final.projected = spTransform(af_dst_final.unprojected, CRS(plot_crs))
```

```{r show_diffusion_to_dst, dependson='forward_filter_to_loc', fig.cap = 'Diffusion that goes from one location to the other, where number of transitions is automatically determined.', warning = FALSE}
library(metR)
library(ggforce)
library(fields)

xlimcuts = c(0.12, .31)
ylimcuts = c(.22, .41)

convex_combination = function(points, alpha) {
  sapply(alpha, function(a) {
    points[1] * (1-a) + points[2] * a
  })
}

xlims = convex_combination(range(coordinates(bathy.projected)[,1]), xlimcuts)
ylims = convex_combination(range(coordinates(bathy.projected)[,2]), ylimcuts)

cut_extents = SpatialPoints(expand.grid(x = xlims, y = ylims), CRS(plot_crs))
cut_extents = spTransform(cut_extents, crs(bathy))

grid_spacing = rdist.earth(coords[1:2,], miles = FALSE)[2] * 1e3

# visualize diffusion against bathymetry and coastline
ggplot(mapping = aes(x = x, y = y), data = df) +
  # diffused mass
  new_scale_fill() +
  geom_tile(mapping = aes(x = lon, y = lat, fill = log_mass,
                          width = grid_spacing, height = grid_spacing, 
                          alpha = .5),
            data = cbind(data.frame(af_dst_final.projected),
                         log_mass = af_dst_final$log_mass),
            inherit.aes = FALSE) +
  scale_fill_viridis_c(na.value = 'transparent', direction = -1) +
  guides(alpha = 'none') + 
    # land mask
  new_scale_fill() +
  guides(fill = 'none') +
  geom_raster(mapping = aes(fill = mask), data = df.land, alpha = .5) +
  scale_fill_viridis_c(na.value = 'transparent') +
  # bathymetry contours
  geom_contour2(mapping = aes(z = depth), data = df, 
                breaks = -template_bin_tops, alpha = .5) + 
  geom_text_contour(mapping = aes(z = depth), data = df, 
                    breaks = -template_bin_tops) + 
  # observations
  geom_point(mapping = aes(x = long, y = lat), inherit.aes = FALSE,
             data = data.frame(animalobs.projected)[obs_ind + 0:1,], 
             size = .5) +
  # map extent labels
  scale_x_continuous(
    breaks = xlims,
    labels = telefit:::lon_trans()$format(
      range(round(cut_extents@coords[,1]))
    ),
    limits = xlims
  ) +
  scale_y_continuous(
    breaks = ylims,
    labels = telefit:::lat_trans()$format(
      range(round(cut_extents@coords[,2]))
    ),
    limits = ylims
  ) +
  # formatting
  coord_equal() + 
  theme_few() + 
  theme(panel.border = element_blank(), 
        axis.title = element_blank(), 
        axis.ticks = element_blank())
```

```{r automatic_diffusions}

# prior information on maximum speed (m/s)
max_speed = 5 

time_n_max = do.call(rbind, lapply(1:nrow(animalobs), function(obs_ind) {
  # x0 = gridInd(coord = animalobs[obs_ind, c('long','lat')], obj = bathy)
  # xf = gridInd(coord = animalobs[obs_ind + 1, c('long','lat')], obj = bathy)
  
  # time between observations (sec)
  dt = diff(as.numeric(animalobs$timestamp[obs_ind + 0:1]))
  
  # approximation: upper bound for number of poisson transitions in time window
  data.frame(dt = dt,
    nmax = qpois(p = .999, lambda = max_speed / grid_spacing * dt)
  )
}))

time_n_max

plot((time_n_max$dt/3600), time_n_max$nmax)

```

We will need to incorporate the depth data as well at some point.  This will 
require building imputations that pass through certain depths at given times.
But somewhat unclear as to how to do this.  We have thought through how to do 
imputations in 2D... we go from (x1,y1) to (x2,y2) in a certain number of steps,
and we have known times this occurs and we use our notion of distance and speed 
to determine how many transitions to consider.  However, we might not be able to 
do the depth checkpoints in the same manner... well, we can of course, if we 
look at the minimum number of transitions required to get to a certain depth 
by a certain time.  The challenge, then, will be to ensure that we can do these 
imputations while still maintaining the ability to make the next GPS checkpoint
since it is possible that the minimum number of transitions required to meet 
the GPS checkpoints will be larger than the minimum number of transitions 
required to meet all of the depth checkpoints.  And if this is the case, then 
how do we allocate the additional checkpoints (for GPS requirements) among the 
transitions to meet the depth checkpoints?  Is equal distribution fine, or 
would it be better to distribute according to a uniform distribution?


# Next steps

- Run a 2D simulation to verify our method does the job well in a simple 
  setting.
- Then, analyze the harbor seal data in 2D.
    - We can probably avoid the multiple imputation issue since our goal is 
      simply to show that our method solves issues that are inherent w/standard
      CTDS AIDs.
- Lastly, analyze sattag data.  See above for some issues that remain TBD
- Add support for inhomogeneous transition speeds?  This will require more 
  complex sampling of the arrival times, but would be completely unnecessary if 
  the method does not even work for homogeneous processes.